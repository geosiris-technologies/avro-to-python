{%- import 'macro.j2' as macros with context -%}
use etptypes::energistics::etp::v12::protocol::core::protocol_exception::ProtocolException;
use etptypes::error::*;

{# 
trait EtpHandler{
	fn handle(header: MessageHeaderFlag, msg: ProtocolMessage) -> Option<Vec<ProtocolMessage>>;
}

{% for k, v in protocols.items() -%}
/* {{ k }} - {{ macros.get_protocol_name(v[0]) }} */
trait {{ macros.get_protocol_name(v[0]) }}Handler: EtpHandler{
	{% for file in v -%}
	fn handle_{{file.name}}(header: MessageHeaderFlag, msg: {{ macros.compute_ns_type_name(file.namespace, file.name) }}) -> Option<Vec<ProtocolMessage>>{
		Some(
			vec!(ProtocolException::default_with_params(Some(eunsupported_protocol())))
		)
	}
	{% endfor %}

	fn handle(header: MessageHeaderFlag, msg: ProtocolMessage) -> Option<Vec<ProtocolMessage>>{
		match msg {
			{%- for file in v %}
			{{ macros.compute_ns_type_name(file.namespace, file.name)}} => handle_{{file.name}}(header, msg)
			{%- endfor %}
			_ => Some(
					vec!(ProtocolException::default_with_params(Some(eunsupported_protocol())))
				)
		}
	}
}
 #}


{# trait EtpMessageHandler<T: ETPMetadata>{
    fn handle(header: MessageHeaderFlag, msg: T) -> Option<Vec<Box<dyn ETPMetadata>>>;
} #}
{# ESSAI 2

trait EtpMessageHandler<T: ETPMetadata>{
	{% for k, v in protocols.items() -%}
	/* {{ k }} - {{ macros.get_protocol_name(v[0]) }} */
	{% for file in v -%}
	fn handle(header: MessageHeaderFlag, msg: {{ macros.compute_ns_type_name(file.namespace, file.name)}}) -> Option<Vec<ProtocolMessage>>{
		Some(
			vec!(ProtocolMessage::Core_ProtocolException::default_with_params(Some(eunsupported_protocol())))
		)
		
	}
	{% endfor -%}
	{% endfor -%}
}

fn handle_message(handler: EtpMessageHandler, msg: ProtocolMessage) -> Option<Vec<ProtocolMessage>>{
	match msg{
	{% for k, v in protocols.items() -%}
		{%- for file in v -%}
			{{ macros.get_protocol_name(file) }}_{{ file.name }} => handler.handle(msg),
		{% endfor -%}
	{% endfor -%}
		_ => None
	}
}
 #}

trait EtpMessageHandler<T: ProtocolMessage>{
    fn handle(header: MessageHeaderFlag, msg: T) -> Option<Vec<ProtocolMessage>>;
}